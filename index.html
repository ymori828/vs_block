<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>2P Block Game</title>
<style>
  html,body{margin:0;height:100%;background:#fff}
  canvas{display:block;touch-action:none}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const COLORS = {
    P1: "#000",  // 下：黒
    P2: "#888"   // 上：グレー
  };

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  const SET = {
    paddleW: 0.3,
    paddleH: 12,
    inset: 16,
    ballR: 0.018,
    speed: 0.55,
    cols: 6,
    rows: 3,
    gap: 8,
    radius: 8   // 角丸半径（ブロック/パドル）
  };

  let W,H,midY;
  let p1,p2,b1,b2,blocksTop=[],blocksBottom=[],winner=null;

  function resize(){
    W=innerWidth;H=innerHeight;midY=H/2;
    canvas.width=W*devicePixelRatio;
    canvas.height=H*devicePixelRatio;
    canvas.style.width=W+"px";
    canvas.style.height=H+"px";
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    reset();
  }
  addEventListener("resize",resize);

  function paddle(isTop){
    const w=W*SET.paddleW;
    return {
      w,h:SET.paddleH,
      x:(W-w)/2,
      y:isTop?SET.inset:H-SET.inset-SET.paddleH
    };
  }

  function ball(isTop,p){
    const r=Math.max(6,W*SET.ballR);
    return {
      r,
      x:p.x+p.w/2,
      y:isTop?p.y+p.h+r+2:p.y-r-2,
      vx:0,vy:0,state:"WAIT",
      shape: isTop ? "star" : "heart" // ★上 / ♥下（当たり判定は円のまま）
    };
  }

  function makeBlocks(isTop){
    const list=[];
    const band=H*0.14;
    const top=isTop?midY-band:midY;
    const usable=W-32;
    const bw=(usable-(SET.cols-1)*SET.gap)/SET.cols;
    const bh=(band-(SET.rows-1)*SET.gap)/SET.rows;
    for(let r=0;r<SET.rows;r++){
      for(let c=0;c<SET.cols;c++){
        list.push({
          x:16+c*(bw+SET.gap),
          y:top+r*(bh+SET.gap),
          w:bw,h:bh,alive:true
        });
      }
    }
    return list;
  }

  function reset(){
    winner=null;
    p2=paddle(true); p1=paddle(false);
    b2=ball(true,p2); b1=ball(false,p1);
    blocksTop=makeBlocks(true);
    blocksBottom=makeBlocks(false);
  }

  function launch(ball,dir){
    const a=(Math.random()*0.5-0.25);
    const s=W*SET.speed;
    ball.vx=Math.sin(a)*s;
    ball.vy=Math.cos(a)*s*dir;
    ball.state="MOVE";
  }

  function collideBallRect(b,o){
    const cx=clamp(b.x,o.x,o.x+o.w);
    const cy=clamp(b.y,o.y,o.y+o.h);
    return (b.x-cx)**2+(b.y-cy)**2<=b.r*b.r;
  }

  function updateBall(b){
    if(b.state!=="MOVE")return;
    b.x+=b.vx*dt; b.y+=b.vy*dt;

    if(b.x<b.r||b.x>W-b.r) b.vx*=-1;

    if(collideBallRect(b,p1)){ b.y=p1.y-b.r; b.vy*=-1; }
    if(collideBallRect(b,p2)){ b.y=p2.y+p2.h+b.r; b.vy*=-1; }

    for(const bl of blocksTop){
      if(bl.alive&&collideBallRect(b,bl)){
        bl.alive=false; b.vy*=-1; break;
      }
    }
    for(const bl of blocksBottom){
      if(bl.alive&&collideBallRect(b,bl)){
        bl.alive=false; b.vy*=-1; break;
      }
    }

    if(b.y<-b.r||b.y>H+b.r){
      b.state="WAIT"; b.vx=b.vy=0;
      if(b===b1){ b.x=p1.x+p1.w/2; b.y=p1.y-b.r-2; }
      if(b===b2){ b.x=p2.x+p2.w/2; b.y=p2.y+p2.h+b.r+2; }
    }
  }

  function checkWin(){
    if(blocksTop.every(b=>!b.alive)) winner="P2";
    if(blocksBottom.every(b=>!b.alive)) winner="P1";
  }

  // 角丸矩形描画
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    ctx.fill();
  }

  // ♥描画（見た目だけ）
  function drawHeart(x, y, r) {
    ctx.beginPath();
    ctx.moveTo(x, y + r * 0.6);
    ctx.bezierCurveTo(
      x - r, y - r * 0.4,
      x - r * 0.8, y - r,
      x, y - r * 0.2
    );
    ctx.bezierCurveTo(
      x + r * 0.8, y - r,
      x + r, y - r * 0.4,
      x, y + r * 0.6
    );
    ctx.closePath();
    ctx.fill();
  }

  // ★描画（見た目だけ）
  function drawStar(x, y, r) {
    const spikes = 5;
    const outer = r;
    const inner = r * 0.45;
    let rot = Math.PI / 2 * 3;

    ctx.beginPath();
    ctx.moveTo(x, y - outer);
    for (let i = 0; i < spikes; i++) {
      ctx.lineTo(x + Math.cos(rot) * outer, y + Math.sin(rot) * outer);
      rot += Math.PI / spikes;
      ctx.lineTo(x + Math.cos(rot) * inner, y + Math.sin(rot) * inner);
      rot += Math.PI / spikes;
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawBallShape(ball, color) {
    ctx.fillStyle = color;
    if (ball.shape === "heart") {
      drawHeart(ball.x, ball.y, ball.r);
    } else if (ball.shape === "star") {
      drawStar(ball.x, ball.y, ball.r);
    } else {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    ctx.fillStyle=COLORS.P2;
    blocksTop.forEach(b=>b.alive&&roundRect(b.x,b.y,b.w,b.h,SET.radius));
    roundRect(p2.x,p2.y,p2.w,p2.h,SET.radius);

    ctx.fillStyle=COLORS.P1;
    blocksBottom.forEach(b=>b.alive&&roundRect(b.x,b.y,b.w,b.h,SET.radius));
    roundRect(p1.x,p1.y,p1.w,p1.h,SET.radius);

    // ボール（見た目：★と♥ / 判定：円）
    drawBallShape(b2, COLORS.P2);
    drawBallShape(b1, COLORS.P1);

    if(winner){
      ctx.fillStyle="#000";
      ctx.font="bold 32px 'Hiragino Maru Gothic ProN','Hiragino Sans',system-ui";
      ctx.textAlign="center";
      const text = winner==="P1" ? "１Pのかち！" : "２Pのかち！";
      ctx.fillText(text,W/2,H/2);
    }
  }

  let last=performance.now(),dt=0;
  function loop(now){
    dt=Math.min(0.033,(now-last)/1000); last=now;
    if(!winner){
      updateBall(b1); updateBall(b2); checkWin();
    }
    draw(); requestAnimationFrame(loop);
  }

  // 発射：自分側の半分をタップ（WAIT中のみ）
  canvas.addEventListener("pointerdown",e=>{
    if (winner) { reset(); return; }
    const y=e.clientY;
    if(y<midY){ if(b2.state==="WAIT") launch(b2,1); }
    else{ if(b1.state==="WAIT") launch(b1,-1); }
  });

  // 移動：指追従（スクロール風）
  canvas.addEventListener("pointermove",e=>{
    const x=e.clientX, y=e.clientY;
    if(y<midY){
      p2.x=clamp(x-p2.w/2,0,W-p2.w);
      if(b2.state==="WAIT") b2.x=p2.x+p2.w/2;
    }else{
      p1.x=clamp(x-p1.w/2,0,W-p1.w);
      if(b1.state==="WAIT") b1.x=p1.x+p1.w/2;
    }
  });

  resize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
